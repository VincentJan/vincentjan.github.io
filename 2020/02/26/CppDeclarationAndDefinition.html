<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="C++的声明与定义 - Vincent's Blog"><meta name="theme-color" content="#ebc65a"><title>C++的声明与定义 - Vincent's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: false,
    orderedList: false,
    collapseDepth: 3,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">Vincent's Blog</a></h1><p>飞光飞光，劝尔一杯酒。</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><a class="text" href="/">Index</a><a class="text" href="/about">About</a><a class="text" href="/repositories">Repositories</a><a class="text" href="/links">Links</a><a class="text" href="/toolbox">Tool Box </a><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">C++的声明与定义</a></h2><span class="post__date">2020-02-26</span><a href="/tags/C/"><span class="post__tags">#C++</span></a></div></div><div class="article__content"><blockquote>
<p>偶然间看见一个声明:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *(*(*<span class="hljs-title">Pfunc</span>)[3])(<span class="hljs-title">int</span>(*)(<span class="hljs-title">int</span>, <span class="hljs-title">int</span>), <span class="hljs-title">float</span>(*[])(<span class="hljs-title">float</span>));</span><br></code></pre></td></tr></table></figure>
<p>一时间感到云里雾里。为了弄懂此类复杂的声明学习一些相关的知识，在此总结。</p>
</blockquote>
<a id="more"></a>
<h2 id="声明与定义的区别"><a href="#声明与定义的区别" class="headerlink" title="声明与定义的区别"></a>声明与定义的区别</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><strong>对于C++中的声明，比较通用的描述为：一条声明语句由一个基本数据类型和紧随其后的一个声明符列表组成。每个声明符命名一个变量并指定该变量为与基本数据类型有关的某种类型。</strong></p>
<p><em>声明语句：  基本数据类型  声明符1&lt;, 声明符2, 声明符3 …&gt;</em></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a, b = <span class="hljs-number">2</span>; <br><span class="hljs-comment">//int为基本数据类型， a,b为一个含有2个声明符的声明符列表，a与b都是声明符，分别声明（并定义）了名称为a, b的int型变量， 并把2赋值给b。</span><br></code></pre></td></tr></table></figure>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>可以看出，这条语句在声明了a, b的同时定义了它们。这里引出了声明和定义的关系：</p>
<p><strong>声明使得名字为程序所知，而定义负责建立名字与实体间的关系。</strong>声明规定了变量的类型与名字，而定义在此基础上为变量分配存储空间，还可能为其赋一个初始值。</p>
<h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p>extern关键字常用于表示一个变量已在其它文件中定义。</p>
<ul>
<li>如果要<strong>声明一个变量而不定义它</strong>，则在声明语句前加上extern</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">//声明int型变量a，但未定义</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>; <span class="hljs-comment">//声明并定义int型变量b，并为其赋初始值2</span><br></code></pre></td></tr></table></figure>
<p>​     <strong><em>任何显式初始化的声明即成为定义*</em></strong>。即使一个声明符已用extern标记，对其进行初始化仍会导致定义行为。*</p>
<ul>
<li><p>对于<strong>多文件</strong>程序，若要在多个文件中使用<strong>同一个变量</strong>，则必须在<strong>所有</strong>使用该变量的文件中<strong>声明</strong>它，但仅可在<strong>一个</strong>文件中<strong>定义</strong>该变量。</p>
</li>
<li><p><strong>不可在函数体内部初始化</strong>一个含有extern标记的变量。</p>
</li>
</ul>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p><strong>复合类型指基于其它类型定义的类型 。</strong></p>
<h3 id="1-引用"><a href="#1-引用" class="headerlink" title="1.引用"></a>1.引用</h3><p>引用即对象的别名，通过将声明符写成&amp;d的形式定义引用类型，其中d是变量名。</p>
<p>引用<strong>并非对象，不占用内存空间</strong>，仅作为一个已存在对象的别名。因此引用<strong>必须初始化，且不能再绑定到其它对象上。</strong></p>
<p>引用<strong>类型要与它所绑定的对象严格匹配</strong>，且<strong>仅能绑定在对象上</strong>，而不能绑定在字面值或表达式的计算结果上。该规则有两个例外：</p>
<ol>
<li>对const的引用初始值可为任一能转换为引用的类型的对象、字面值或表达式结果。</li>
<li>基类的引用或指针可绑定到派生类对象上。</li>
</ol>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> &amp;r;	<span class="hljs-comment">//X, 引用必须初始化</span><br><span class="hljs-keyword">int</span> &amp;ri = i;<br><span class="hljs-keyword">double</span> &amp;rdi = i;<span class="hljs-comment">//X, 引用类型不匹配</span><br><span class="hljs-keyword">double</span> &amp;rd = <span class="hljs-number">3.14</span>;<span class="hljs-comment">//X, 非const引用必须绑定到对象上</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;crdi = i;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> &amp;crd = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2.指针"></a>2.指针</h3><p>指针存放对象的地址，通过将声明符写成<em>d的形式定义，其中d是变量名。由于指针存放的并非对象，而是对象的地址，故需要<strong>用取地址符&amp;取得对象地址。操作其绑定的对象时也要使用解引用符\</strong></em>。</p>
<p>取地址符&amp;与引用声明符虽然使用同一个符号，但意义不同，一个作用于声明符，一个作用于对象。</p>
<p>解引用符*与指针声明符亦然，另外解引用符和引用没有关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> *pa = &amp;a; <span class="hljs-comment">//pa是a的指针， &amp;是取地址符</span><br><span class="hljs-keyword">int</span> &amp;ra = a; <span class="hljs-comment">//ra是a的引用， &amp;是引用声明符</span><br>ra = <span class="hljs-number">3</span>;	<span class="hljs-comment">//通过引用改变a的值</span><br>*pa = <span class="hljs-number">0</span>;<span class="hljs-comment">//通过指针改变a的值</span><br>pa = <span class="hljs-number">0</span>;<span class="hljs-comment">//改变指针本身的值</span><br></code></pre></td></tr></table></figure>
<p>指针与引用类似，但有两点不同：</p>
<ol>
<li>指针本身是一个对象，允许赋值和拷贝。</li>
<li>指针无须在定义时赋初始值，且在函数体内定义的指针有一个不确定的初始值。</li>
</ol>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ol>
<li><p>空指针: 不指向任何对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p1 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//C++11</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> *p3 = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//#include&lt;cstdlib&gt;, 值等于0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>void*指针：可指向任何对象，且不能操作所指对象。</p>
</li>
<li><p>指向指针的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p1;<br><span class="hljs-keyword">int</span> **p2 = p1;<br></code></pre></td></tr></table></figure>
</li>
<li><p>指向数组的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> (*p1)[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>函数指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> (*p1)(&lt;参数列表&gt;) = test;<br><span class="hljs-keyword">int</span> (*p2)(&lt;参数列表&gt;) = &amp;test;<span class="hljs-comment">//函数指针赋值时可以不用取地址</span><br>p1(&lt;&gt;);<span class="hljs-comment">//函数指针使用时可以不用解引用</span><br>(*p1)(&lt;&gt;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>指针的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *p1[<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>
</li>
<li><p>常量指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p1 = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><ul>
<li><p>const<strong>作用于基本类型</strong>或与*连写成<strong>*const</strong>（只要在*后就表示指针本身是常量，与*间可有空格）用以声明常量指针，受const影响的变量的值不能被改变。</p>
</li>
<li><p>const对象<strong>仅在文件内有效</strong>，若要在其它文件中使用则需要在<strong>所有声明或定义</strong>语句前<strong>加extern</strong></p>
</li>
<li><p>引用可绑定到const对象上形成对const的引用，也称<strong>常量引用</strong>。非常量引用无法绑定常量对象。</p>
</li>
<li><p>常量引用<strong>不可用作修改对象的值</strong>，另一方面<strong>其初始值可为任一能转换为引用的类型的对象、字面值或表达式结果</strong>，此时该常量引用实际<strong>绑定了一个临时量</strong>。</p>
</li>
<li><p>对于指针而言，<strong>指针本身是const称为顶层const，指针指向的对象是const称为底层const</strong>。仅底层const可用于指向常量对象。</p>
</li>
<li>在<strong>类成员函数参数列表后使用const</strong>将该函数声明为const成员函数，其内在原理为作用于隐式参数<em>this</em>指针，从而使其能指向常量对象。因此<strong>类的const对象仅能调用const成员函数</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; <span class="hljs-comment">//i的值可变</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = i; <span class="hljs-comment">//不可通过ri改变i的值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *pib = &amp;i; <span class="hljs-comment">//不可通过pib改变i的值， 可改变pib的值</span><br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> pib = &amp;i; <span class="hljs-comment">//可通过pib改变i的值， 不可改变pib的值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> pib = &amp;i;<span class="hljs-comment">//不可通过pib改变i的值， 不可改变pib的值</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> &amp;rj = j; <span class="hljs-comment">//X</span><br><span class="hljs-keyword">int</span> *pj = j; <span class="hljs-comment">//X</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span>* pj = j; <span class="hljs-comment">//X，必须是底层const才能绑定const对象。</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">class A&#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">	void HW()&#123;cout &lt;&lt; "HelloWorld" &lt;&lt; endl;&#125;</span><br><span class="hljs-comment">	void HW_c() const &#123;cout &lt;&lt; "HelloWorld" &lt;&lt; endl;&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br>A a1;<br>a1.HW(); <span class="hljs-comment">//合法</span><br>a1.HW_c();<span class="hljs-comment">//合法，普通对象可调用const成员函数</span><br><span class="hljs-keyword">const</span> A a2;<br>a2.HW();<span class="hljs-comment">//非法，即使非常量成员函数内没有改变对象的操作，仍不能被const对象调用</span><br>a2.HW_c();<span class="hljs-comment">//合法</span><br></code></pre></td></tr></table></figure>
<h2 id="constexpr关键字"><a href="#constexpr关键字" class="headerlink" title="constexpr关键字"></a>constexpr关键字</h2><p>常量表达式指在编译时就能得到值且不会改变的表达式。常见的有字面值与用常量表达式初始化的const对象。</p>
<p>实际使用时往往很难确定一个表达式是否是常量表达式。此时可用constexpr声明该变量， 以由编译器检查其是否为常量表达式。</p>
<p>constexpr在声明指针时，会将指针设为顶层const。</p>
<p>constexpr函数需要满足：</p>
<ul>
<li>返回类型及所有形参类型都是字面值类型。</li>
<li>函数体中有且只有一条return语句。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *p = null; <span class="hljs-comment">//p是指向整数的常量指针</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p1 = null;	<span class="hljs-comment">//p1是指向整数常量的指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p2 = null;	<span class="hljs-comment">//p2是指向整数常量的常量指针</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3 = null;	<span class="hljs-comment">//p3是指向整数常量的常量指针</span><br></code></pre></td></tr></table></figure>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static将作用对象声明为静态对象，有四种主要用法：</p>
<ol>
<li>对于<strong>全局或命名空间</strong>作用域，使用static标记声明符使该对象<strong>仅在此文件可用</strong>。</li>
<li><p>对于在<strong>函数</strong>作用域定义的变量，使用static标记使该变量在函数<strong>调用结束后不被释放</strong>。</p>
</li>
<li><p>对于在<strong>类</strong>作用域定义的<strong>数据成员</strong>，使用static标记使该成员为<strong>整个类共用</strong>而不属于任何对象。通常类的静态成员必须<strong>在类外定义及初始化</strong>，且<strong>不能在类外重复使用static</strong>。</p>
<ul>
<li><em>字面值常量类型的constexpr静态数据成员（常量表达式并不一定是用constexpr关键字定义的）可在类内用const整数类型的初始值初始化。即便如此，仍应在类外定义该成员，否则任何编译器不能直接用该成员的值替换该成员的场景都会引起错误。且此时在类外的定义不能再提供初始值。</em></li>
</ul>
</li>
<li><p>对于在<strong>类</strong>作用域定义的<strong>函数成员</strong>，使用static标记使该成员为<strong>整个类共用</strong>。静态成员函数不与任何对象绑定，不包含<em>this</em>指针，因此不能声明为const类型 。静态函数成员仅能使用其它静态成员。</p>
</li>
</ol>
<ul>
<li>union的成员不能声明成static类型 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//a.cpp</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//b.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a;	<span class="hljs-comment">//X, a.cpp内定义的a只能在本文件使用</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> b;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 合法， 重新定义了一个a</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>; <span class="hljs-comment">//非法， 重复定义</span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">4</span>;	<span class="hljs-comment">//合法</span><br><span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>; <span class="hljs-comment">//非法</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; <span class="hljs-comment">//错误， 不可在类内初始化普通静态成员</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> d;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> e = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> f = <span class="hljs-number">10</span>; <span class="hljs-comment">//在确定表达式为常量表达式时也可以使用const</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HelloWorld</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"HelloWorld!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HW</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//错误，不可重复static</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> A::HW()&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"HW"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> A::HW()&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"HW"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-keyword">int</span> A::d = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">constexpr</span> A::e;<br><br><span class="hljs-comment">//void AnotherFunc(const int &amp;A);</span><br>AnotherFunc(A::e); <br>AnotherFunc(A::f);<span class="hljs-comment">//错误，未在类外定义</span><br></code></pre></td></tr></table></figure>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><h3 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h3><p>typedef &lt;声明语句&gt;  &lt;别名&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">typedef int (*origin)[10] now; //将声明语句表示的类型用now指代<br>now p2; <span class="hljs-comment">//等价于 int (*p2)[10]</span><br></code></pre></td></tr></table></figure>
<h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><p>using  &lt;名称1&gt; = &lt;名称2&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SI = StringItem; <span class="hljs-comment">//令SI等价于StringItem</span><br>SI s; <span class="hljs-comment">//等价于 StringItem s;</span><br></code></pre></td></tr></table></figure>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><h3 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h3><p>通过初始值推导类型，故而必须初始化。</p>
<ul>
<li>用引用初始化以auto声明的变量时，变量会以引用的对象类型作为变量类型。如需引用类型需要明确指出。</li>
<li>以指针初始化auto声明的变量时，会忽略顶层const。如需顶层const需要明确指出。</li>
<li>要在一条语句中声明多个变量，它们的初始值应该相同。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> &amp;a = i;<br><span class="hljs-keyword">int</span> *p = i;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p1 = i;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p2 = i;<br><span class="hljs-keyword">auto</span> ii = i; <span class="hljs-comment">//ii为int</span><br><span class="hljs-keyword">auto</span> aa = a; <span class="hljs-comment">//aa为int</span><br><span class="hljs-keyword">auto</span> pp = p; <span class="hljs-comment">//pp为int*</span><br><span class="hljs-keyword">auto</span> pp1 = p1; <span class="hljs-comment">//pp1为 const int*</span><br><span class="hljs-keyword">auto</span> pp2 = p2; <span class="hljs-comment">//pp2为 const int*</span><br><br><span class="hljs-keyword">auto</span> &amp;raa = a; <span class="hljs-comment">//raa为int&amp;</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> cpp1 = p1; <span class="hljs-comment">//cpp1为 const int const*</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;rii = i; <span class="hljs-comment">//rii为 const int&amp;</span><br><br><span class="hljs-keyword">auto</span> b = rii, c = raa;<span class="hljs-comment">//X, rii为const int, raa为int</span><br></code></pre></td></tr></table></figure>
<h3 id="decltype关键字"><a href="#decltype关键字" class="headerlink" title="decltype关键字"></a>decltype关键字</h3><p>decltype(表达式) &lt;声明符&gt;</p>
<ul>
<li><p>decltype检查表达式的值类型，但<strong>不实际计算该表达式</strong>。</p>
</li>
<li><p>decltype并不会改变顶层const和引用。</p>
<ul>
<li>引用仅在这种用途时不作为其绑定对象的同义词。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> &amp;r = i;<br><span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p = &amp;i;<br><br><span class="hljs-keyword">decltype</span>(r) rr = i; <span class="hljs-comment">//rr为 int&amp;</span><br><span class="hljs-keyword">decltype</span>(p) pp = null;<span class="hljs-comment">//pp为 int *const</span><br></code></pre></td></tr></table></figure>
<h3 id="复杂声明的理解"><a href="#复杂声明的理解" class="headerlink" title="复杂声明的理解"></a>复杂声明的理解</h3><p><strong>由内而外，由右及左。</strong></p>
<p>即优先找离声明符最近的复合类型声明。对于距离声明符距离相同的复合类型声明，优先处理声明符右边。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *(*(*<span class="hljs-title">Pfunc</span>)[3])(<span class="hljs-title">int</span>(*)(<span class="hljs-title">int</span>, <span class="hljs-title">int</span>), <span class="hljs-title">float</span>(*[])(<span class="hljs-title">float</span>));</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	1.首先，要找到主声明符的名字，这里是Pfunc</span><br><span class="hljs-comment">	2.找离Pfunc最近的复合类型声明，越近则影响越大，这里离Pfunc最近的是*，即Pfunc最本质上是一个指针。</span><br><span class="hljs-comment">	3.采用由内而外，由右及左的顺序分析，出于语序最好使用英文</span><br><span class="hljs-comment">	Pfunc is a pointer to an array(size 3) about pointer to function(C1, C2) return a pointer to struct tm.</span><br><span class="hljs-comment">	C1: a pointer to a function(int , int) return int</span><br><span class="hljs-comment">	C2: an array about pointer to a function(float) return float</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *(*&amp;i)[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	i is a reference for pointer to an array(size 3) about pointer to const int;</span><br><span class="hljs-comment">	const作用是修饰基本类型，不影响判断</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Contact Me</h2><div class="sidebar__link"><ul><li><a href="https://github.com/VincentJan" target="_blank" rel="noopener">Github</a></li><li><a href="mailto:vincentjan200@163.com">Mail</a></li></ul></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%89%B9%E5%8F%97%E8%8B%A6%E4%B9%8B%E6%97%85/">C艹受苦之旅</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E6%8A%98%E8%85%BE%E8%AE%B0/">Linux折腾记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8D%E5%86%99%E7%A8%8B%E5%BA%8F/">不写程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%98%E5%BD%95/">摘录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9%E5%84%BF%E8%9B%87/">玩儿蛇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%85%E4%BA%8B/" rel="tag">故事</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B9%E6%B3%95/" rel="tag">方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%9E%84%E6%96%87%E5%AD%A6%E5%88%9B%E4%BD%9C%E7%BB%83%E4%B9%A0/" rel="tag">虚构文学创作练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97/" rel="tag">诗</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2020/03/20/ArchLinuxConfig.html">Arch Linux安装与配置</a><a class="next-button" href="/2019/11/15/%E5%B0%8F%E5%BC%A0%E5%92%8C%E5%B0%8F%E4%B8%BD.html">小张和小丽 ——开开550</a></div></div></div></div><div class="footer"><span>©️2019-2020 Theme Designed By&nbsp;<strong><a href="https://github.com/random-yang" target="_blank" rel="noopener">RandomYang</a></strong> Powered By&nbsp;</span><strong><a href="https://hexo.io" target="_blank" rel="noopener">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>