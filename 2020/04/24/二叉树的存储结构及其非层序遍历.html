<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"><meta name="description" content="二叉树的存储结构及其非层序遍历 - Vincent's Blog"><meta name="theme-color" content="#ebc65a"><title>二叉树的存储结构及其非层序遍历 - Vincent's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><script src="https://cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js" defer></script><script src="/js/paper.js" defer></script><link rel="stylesheet" href="/css/tocbot.css"><script src="/js/tocbot.js" defer></script><script>window.addEventListener('DOMContentLoaded', () => {
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.toc__content',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.article__content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    // For headings inside relative or absolute positioned containers within content.
    hasInnerContainers: false,
    orderedList: false,
    collapseDepth: 3,
  });
})</script><link rel="preload" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"><link rel="preload" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface&amp;display=swap"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="mask-border"></div><div class="head"><div class="head__inner"><h1><a href="/">Vincent's Blog</a></h1><p>飞光飞光，劝尔一杯酒。</p></div></div><div class="paper-container"><div class="main"><div class="location-bar"><div class="line-1"><div class="horizontal-line" style="height: 3px"></div></div><div class="line-2"><div class="horizontal-line" style="height: 1px"></div></div><i class="text">Elohim. Essaim. </i><div class="switch-button"><input class="container_toggle" type="checkbox" id="switch" name="mode"><label for="switch">Toggle</label></div><div class="line-3"><div class="horizontal-line" style="height: 1px"></div></div></div><div class="main__2-col"><article class="post-view__article"><div class="article__infomation"><div class="posts-item"><h2 class="posts-item__title"><a href="">二叉树的存储结构及其非层序遍历</a></h2><span class="post__date">2020-04-24</span><a href="/tags/C/"><span class="post__tags">#C++</span></a><a href="/tags/%E7%AE%97%E6%B3%95/"><span class="post__tags">#算法</span></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="post__tags">#数据结构</span></a><a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"><span class="post__tags">#二叉树</span></a></div></div><div class="article__content"><blockquote>
<p>二叉树是我接触的第一个非线性数据结构。在对它进行操作前，如何对其进行构建与遍历很自然地成为了首先要关心的问题。</p>
<p>这篇文章总结了：</p>
<ol>
<li>二叉树的五个性质</li>
<li>如何存储一个二叉树</li>
<li>二叉树的先序、中序和后序遍历及其非递归实现</li>
<li>以及通过二叉树中序序列+先序/后序序列构建二叉树的方法</li>
<li>如何计算一对先序序列和后序序列可能表示的二叉树个数。</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="二叉树的五个性质"><a href="#二叉树的五个性质" class="headerlink" title="二叉树的五个性质"></a>二叉树的五个性质</h2><ol>
<li><p>二叉树的第i层上至多有2^(i - 1)个结点</p>
</li>
<li><p>深度为k的二叉树至多有2^k - 1个结点</p>
</li>
<li><p>对任何一棵二叉树T, 其终端结点数 = 度为2的结点数 + 1</p>
</li>
<li><p>具有n个结点的完全二叉树深度为：log2(n) + 1</p>
<p> 满二叉树：每一层结点数都为最大</p>
<p> 完全二叉树：每一结点按层的编号都与对应的满二叉树一一对应</p>
<p> <img src="/img/NoteImg/20200424/image-20200422231103355.png" alt="image-20200422231103355"></p>
<p> <em>a.满二叉树    b.完全二叉树</em></p>
</li>
<li><p>对一颗有n个结点的完全二叉树，将其结点按层序编号i，有</p>
<ol>
<li><p>i=1，则该结点为根结点，无双亲</p>
</li>
<li><p>2i&gt;n，则结点i无左孩子，否则其左孩子是2i</p>
</li>
<li><p>2i + 1 &gt; n则结点无右孩子，否则其右孩子是2i + 1</p>
</li>
</ol>
</li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1. 顺序存储结构"></a>1. 顺序存储结构</h3><p>将完全二叉树上序号为i的结点存在数组中标号为i - 1的地址中，如非完全二叉树，则空出来的地址留空。此时子结点用性质5即可得到。</p>
<p><img src="/img/NoteImg/20200424/image-20200422233319114.png" alt="image-20200422233319114"></p>
<p>上面三个二叉树的存储结构分别为：</p>
<p><img src="/img/NoteImg/20200424/image-20200422233546201.png" alt="image-20200422233546201"></p>
<p><em>(用0表示结点不存在)</em></p>
<p>可以看出，当二叉树不是完全二叉树时，这种结构非常浪费存储空间。因此仅适合用作完全二叉树的存储。</p>
<h3 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2. 链式存储结构"></a>2. 链式存储结构</h3><p>二叉树用链表来存储是非常自然的，常见的有二叉链表和三叉链表。</p>
<h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h4><p>二叉链表的组织形式：</p>
<p><img src="/img/NoteImg/20200424/image-20200422234628192.png" alt="image-20200422234628192"></p>
<p><img src="/img/NoteImg/20200424/image-20200422234844999.png" alt="image-20200422234844999"></p>
<h4 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h4><p>三叉链表在二叉链表的基础上添加了指向父结点的指针，与二叉链表大同小异。</p>
<p>三叉链表的组织形式：</p>
<p><img src="/img/NoteImg/20200424/image-20200422235517745.png" alt="image-20200422235517745"></p>
<p><img src="/img/NoteImg/20200424/image-20200422235734363.png" alt="image-20200422235734363"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    Node *leftChild;<br>    Node *rightChild;<br>    <span class="hljs-keyword">int</span> data;<br>&#125; *BinTree;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CreateBinTree</span><span class="hljs-params">(BinTree &amp;tree)</span></span><br><span class="hljs-function"></span>&#123;<br>    tree = <span class="hljs-keyword">new</span> Node&#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(tree == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error While Create BinTree!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InsertChild</span><span class="hljs-params">(Node *aim, <span class="hljs-keyword">bool</span> left)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *newNode = <span class="hljs-keyword">new</span> Node&#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(newNode == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Error While Add Note!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left)<br>    &#123;<br>        aim-&gt;leftChild = newNode;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        aim-&gt;rightChild = newNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DeleteChild</span><span class="hljs-params">(Node *aim, <span class="hljs-keyword">bool</span> left)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(aim == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    Node *preDel = (left) ? aim-&gt;left : aim-&gt;right;<br>    <span class="hljs-keyword">if</span>(preDel != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(preDel-&gt;left != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            DeleteChild(preDel, left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(preDel-&gt;right != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            DeleteChild(preDel, right);<br>  &#125;<br>        <span class="hljs-keyword">delete</span> preDel;<br>        preDel = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left)<br>    &#123;<br>        aim-&gt;left = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        aim-&gt;right = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Visit</span><span class="hljs-params">(Bintree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; T-&gt;data &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>要遍历二叉树，可将二叉树分为三个部分，左子树(L)、根(D)、右子树(R)，并依次访问每个部分。若规定左子树一定先于右子树访问，则共有三种情况：DLR、LDR、LRD。分别称为前（先）序遍历、中序遍历和后序遍历。</p>
<p>这三种遍历的算法是递归描述的，如下：</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>若二叉树为空，则空操作，否则</p>
<ol>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
<h4 id="算法的递归实现"><a href="#算法的递归实现" class="headerlink" title="算法的递归实现"></a>算法的递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DLR</span><span class="hljs-params">(BinTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(Visit(T) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(DLR(T-&gt;left) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(DLR(T-&gt;right) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>若二叉树为空，则空操作，否则</p>
<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
<h4 id="算法的递归实现-1"><a href="#算法的递归实现-1" class="headerlink" title="算法的递归实现"></a>算法的递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LDR</span><span class="hljs-params">(BinTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(LDR(T-&gt;left) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(Visit(T) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(LDR(T-&gt;right) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>若二叉树为空，则空操作，否则</p>
<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ol>
<h4 id="算法的递归实现-2"><a href="#算法的递归实现-2" class="headerlink" title="算法的递归实现"></a>算法的递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LRD</span><span class="hljs-params">(BinTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(LRD(T-&gt;left) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(LRD(T-&gt;right) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(Visit(T) == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="三种遍历的非递归实现"><a href="#三种遍历的非递归实现" class="headerlink" title="三种遍历的非递归实现"></a>三种遍历的非递归实现</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>由上面的描述可以看出用递归实现三种遍历是非常简洁自然的，然而在大部分情况下递归实现的性能开销大于非递归实现（函数反复调用以及系统堆栈带来的），因此在非常需要考虑性能时可以使用算法的非递归实现（算法的递归几乎都可以转化成非递归实现）。</p>
<p>为了实现非递归遍历，先来看看遍历过程中发生了什么。</p>
<p>在遍历过程中，每个结点有三次访问机会，即指针从父结点指向自身，从左孩子退回，从右孩子退回。这里我们不妨规定没有左/右孩子的结点仍能获得空指针退回的访问机会（即将空指针看做一个无法进入的孩子结点）。</p>
<p><img src="/img/NoteImg/20200424/image-20200423090748670.png" alt="image-20200423090748670"></p>
<p>由于我们规定了左子树一定在右子树之前遍历，整个树的遍历顺序就如上图所示(a-&gt;b)。我们在每个结点的左侧、下侧和右侧分别设定一个触发点，并将它们在遍历路径中出现的顺序记录下来。</p>
<p>对于左触发点：ABDECFG</p>
<p>对于下触发点：DBEAFCG</p>
<p>对于右触发点：DEBFGCA</p>
<p>可以看出，它们分别是这个二叉树的前序序列、中序序列和后序序列。因此，实现正确的遍历顺序，并在合适的时机访问结点，就可以实现非递归地遍历二叉树。</p>
<h4 id="前序遍历和中序遍历"><a href="#前序遍历和中序遍历" class="headerlink" title="前序遍历和中序遍历"></a>前序遍历和中序遍历</h4><p>前序遍历和中序遍历的实现相对后序遍历简单，描述为：</p>
<ol>
<li>向左一路前进，若下一结点为空则退栈，否则将其压入栈中。</li>
<li>若指针是左子树退回，则进入右子树。若指针是右子树退回，则表示当前层遍历结束，继续退一层。这也意味着进入右子树时可以将当前结点直接退栈。</li>
<li>栈为空时，遍历完成。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LDR</span><span class="hljs-params">(BinTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//定义一个存储遍历信息的栈和一个用来遍历树的指针</span><br>    <span class="hljs-built_in">stack</span>&lt;Node*&gt; S;<br>    Node *cur = T;<br>    <span class="hljs-comment">//每访问一个结点就将结点出栈，因此以栈非空作为循环条件</span><br>    <span class="hljs-comment">//最后出栈的必是一个叶子结点，因此指针的值在结束时必为nullptr</span><br>    <span class="hljs-keyword">while</span>(!S.empty() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-comment">//指针非空时一路向左走并将沿途结点压入栈中</span><br>        <span class="hljs-comment">//指针为空则表示走到了当前路径的尽头，将最后入栈的结点出栈并令指针指向该结点的右子树</span><br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            S.push(cur);<br>            <span class="hljs-comment">//cout &lt;&lt; cur-&gt;data; 前序时在此输出。</span><br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cur = S.top();<br>            S.pop();<br>            <span class="hljs-built_in">cout</span> &lt;&lt; cur-&gt;data; <span class="hljs-comment">//中序时在此输出。</span><br>            cur = cur-&gt;right;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：一路向左，非空则进。遇空出栈，右子代之。</p>
<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>在前面的代码中我们实际上省略了对指针是由左子树退回还是右子树退回的判断，直接在指针进入右子树时将当前结点出栈。对于前序遍历和中序遍历而言这样做并没有影响，因为它们的访问操作都在指针进入右子树之前。但是对于后序遍历显然是不行的，这里对上述算法进行改进：</p>
<ol>
<li>指针非空时向左前进到底，若指针非空则压入栈中，初始化一个指针保存最近出栈的结点。</li>
<li>指针为空时令指针指向栈顶，进行判定，若指针的右子树存在且没有遍历过则进入右子树，否则输出指针所指元素并退栈。同时将指针置零以免将已退栈的元素重新入栈。</li>
<li>栈为空时，遍历完成。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LRD</span><span class="hljs-params">(BinTree T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">stack</span>&lt;Node*&gt; S;<br>    Node *cur = T;<br>    <span class="hljs-comment">//存储最后退栈的元素</span><br>    Node *lastPop = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span>(!S.empty() || cur != <span class="hljs-literal">nullptr</span>)<br>    &#123; <br>        <span class="hljs-comment">//非空时向左前进到底</span><br>        <span class="hljs-keyword">if</span>(cur != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//cout &lt;&lt; cur-&gt;data; 仍然可用于前序遍历</span><br>            S.push(cur);<br>            cur = cur-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cur = S.top();<br>            <span class="hljs-comment">//判定当前结点是否存在右子树以及右子树是否遍历过</span><br>            <span class="hljs-comment">//此处是否存在的判定是必要的，否则当lastPop非空而当前结点又不存在右子树时，</span><br>            <span class="hljs-comment">//将导致指针不断尝试进入不存在的右子树引发死循环</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;right != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;right != lastPop)<br>            &#123;<br>                <span class="hljs-comment">//cout &lt;&lt; cur-&gt;data; 中序遍历输出根结点</span><br>                cur = cur-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//右子树不存在或已遍历过，输出根结点并退栈</span><br>                S.pop();<br>                <span class="hljs-built_in">cout</span> &lt;&lt; cour-&gt;data;<br>                <span class="hljs-comment">//if(cur-&gt;right == nullptr) cout &lt;&lt; cur-&gt;data; 中序遍历输出叶子结点</span><br>                <span class="hljs-comment">//令lastPop指向最后退栈结点，将cur指针置0以免下一轮循环将已退栈的结点重新入栈</span><br>                lastPop = cur;<br>                cur = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：一路向左，非空则进，遇空判定，有右则进，无右则出，不忘置零。</p>
<h3 id="图解后序遍历的非递归算法"><a href="#图解后序遍历的非递归算法" class="headerlink" title="图解后序遍历的非递归算法"></a>图解后序遍历的非递归算法</h3><p><img src="/img/NoteImg/20200424/LRD.gif" alt="LRD"></p>
<p>精力有限，只好挑一个难度最大的做图解。</p>
<h2 id="通过中序序列-前序-后序序列构建二叉树"><a href="#通过中序序列-前序-后序序列构建二叉树" class="headerlink" title="通过中序序列+前序/后序序列构建二叉树"></a>通过中序序列+前序/后序序列构建二叉树</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>前序序列中任一子树以根结点-左子树-右子树的结构排列。</p>
</li>
<li><p>中序序列中任一子树以左子树-根结点-右子树的结构排列。</p>
</li>
<li><p>后序序列中任一子树以左子树-右子树-根结点的结构排列。</p>
</li>
</ul>
<p>根据以上性质，可以得到算法：</p>
<ol>
<li>从前/后序序列中取首/尾元素，确定树的根结点</li>
<li>在中序序列中搜索根结点，确定左子树和右子树</li>
<li>对左子树和右子树分别重复这个过程，直到不可再分</li>
</ol>
<h4 id="图解：以前序-中序构建为例"><a href="#图解：以前序-中序构建为例" class="headerlink" title="图解：以前序-中序构建为例"></a>图解：以前序-中序构建为例</h4><p><img src="/img/NoteImg/20200424/image-20200424000842475.png" alt="image-20200424000842475"></p>
<p><img src="/img/NoteImg/20200424/Build.jpg" alt="build"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>前序-中序构建二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//根据前序-中序序列构建二叉树，代码是通过递归实现的</span><br><span class="hljs-comment">//SI是string::iterator类型，函数的四个参数分别指向</span><br><span class="hljs-comment">//前序序列p的首元素和尾后元素，中序序列m的首元素和尾后元素</span><br><span class="hljs-function">BinTree <span class="hljs-title">Pre_Mid_Build</span><span class="hljs-params">(SI p_begin, SI p_end, SI m_begin, SI m_end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//用前序序列的首元素初始化一个仅有根结点的树</span><br>    Node *boot = <span class="hljs-keyword">new</span> Node&#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, *p_begin&#125;;<br>    <span class="hljs-comment">//左子树的前序序列首元素地址为当前前序序列的首元素地址+1</span><br>    <span class="hljs-comment">//中序序列的首元素地址和当前中序序列相同</span><br>    <span class="hljs-keyword">auto</span> left_p_begin = p_begin + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//左子树中序序列的尾后地址为根结点在当前中序序列中出现的位置</span><br>    <span class="hljs-comment">//搜索当前中序序列求出，并求出左子树的长度</span><br>    <span class="hljs-keyword">auto</span> left_m_end = m_begin;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*left_m_end != *p_begin)<br>    &#123;<br>        ++left_m_end;<br>        ++num;<br>    &#125;<br>    <span class="hljs-comment">//利用左子树的长度求出左子树前序序列的尾后迭代器</span><br>    <span class="hljs-keyword">auto</span> left_p_end = left_p_begin + num;<br>    <span class="hljs-comment">//若左子树存在，递归构建左子树</span><br>    <span class="hljs-keyword">if</span>(m_begin != left_m_end) <br>    &#123;<br>        boot-&gt;left = Pre_Mid_Build(left_p_begin, left_p_end, m_begin, left_m_end);<br>    &#125;<br>    <span class="hljs-comment">//右子树的迭代器比较方便取得</span><br>    <span class="hljs-keyword">auto</span> right_p_begin = left_p_end;<br>    <span class="hljs-keyword">auto</span> right_m_begin = left_m_end + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//若右子树存在，递归构建右子树</span><br>    <span class="hljs-keyword">if</span>(right_m_begin != m_end)<br>    &#123;<br>        boot-&gt;right = Pre_Mid_Build(right_p_begin, p_end, right_m_begin, m_end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> boot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>中序-后序构建二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码与前序-中序大同小异，不再写注释</span><br><span class="hljs-function">BinTree <span class="hljs-title">Post_Mid_Build</span> <span class="hljs-params">(SI p_begin, SI p_end, SI m_begin, SI m_end)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *boot = <span class="hljs-keyword">new</span> Node&#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, *(p_end - <span class="hljs-number">1</span>)&#125;;<br>    <span class="hljs-keyword">auto</span> left_m_end = m_begin;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*left_m_end != *(p_end - <span class="hljs-number">1</span>))<br>    &#123;<br>        ++left_m_end;<br>        ++num;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> left_p_end = p_begin + num;<br>    <span class="hljs-keyword">if</span>(m_begin != left_m_end) <br>    &#123;<br>        boot-&gt;left = Post_Mid_Build (p_begin, left_p_end, m_begin, left_m_end);<br>    &#125;<br>    <span class="hljs-keyword">auto</span> right_p_begin = left_p_end;<br>    <span class="hljs-keyword">auto</span> right_p_end = p_end - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> right_m_begin = left_m_end + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(right_m_begin != m_end)<br>    &#123;<br>        boot-&gt;right = Post_Mid_Build (right_p_begin, right_p_end, right_m_begin, m_end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> boot;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="计算一对先序序列和后序序列可能表示的二叉树个数"><a href="#计算一对先序序列和后序序列可能表示的二叉树个数" class="headerlink" title="计算一对先序序列和后序序列可能表示的二叉树个数"></a>计算一对先序序列和后序序列可能表示的二叉树个数</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>前序序列中任一子树以根结点-左子树-右子树的结构排列。</p>
</li>
<li><p>后序序列中任一子树以左子树-右子树-根结点的结构排列。</p>
</li>
</ul>
<p>可能混淆的情况有：根（左/右）+（左/右）根。</p>
<p>可以知道，前序序列与后序序列中任何有两个子树的树都是确定的。而每一对仅一个子树的树将有两种可能结构。</p>
<p>因此只要求出序列对中有多少对无法确定的子树即可，很容易发现这样的树对以AB &amp; BA的方式存在。只要搜索两个序列即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//因为要用到位运算， 使用无符号类型</span><br><span class="hljs-keyword">using</span> UL = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">string</span> pre, post;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; pre &gt;&gt; post;<br>    <span class="hljs-comment">//搜索并计数</span><br>    UL sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(UL i = <span class="hljs-number">0</span>; i &lt; pre.length() - <span class="hljs-number">1</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(UL j = <span class="hljs-number">1</span>; j &lt; post.length(); ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(pre[i] == post[j] &amp;&amp; pre[i + <span class="hljs-number">1</span>] == post[j - <span class="hljs-number">1</span>])<br>            &#123;<br>                ++sum;<br>            &#125;<br>        &#125;<br>    &#125;<br>    UL base = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//位运算计算2的次幂方便且快速，注意括号</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; (base&lt;&lt;sum) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</div></article><div class="post-view__sidebar"><div class="sidebar"><div class="tocbot"><h2>Toc</h2><div class="toc__content"></div></div><h2>Archives</h2><div class="sidebar__archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li></ul></div><h2>Links</h2><div class="sidebar__link"><ul><li><a href="/about">About</a></li><li><a href="/repositories">Repositories</a></li><li><a href="/friends">Friends</a></li><li><a href="https://github.com/VincentJan" target="_blank" rel="noopener">Github</a></li><li><a href="mailto:vincentjan200@163.com">Mail</a></li></ul></div><h2>Categories</h2><div class="sidebar__categories"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%89%B9%E5%8F%97%E8%8B%A6%E4%B9%8B%E6%97%85/">C艹受苦之旅</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E6%8A%98%E8%85%BE%E8%AE%B0/">Linux折腾记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%8D%E5%86%99%E7%A8%8B%E5%BA%8F/">不写程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%91%98%E5%BD%95/">摘录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%A9%E5%84%BF%E8%9B%87/">玩儿蛇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6/">读书</a></li></ul></div><h2>Tags</h2><div class="sidebar__tags"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="tag">前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%85%E4%BA%8B/" rel="tag">故事</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B9%E6%B3%95/" rel="tag">方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%9A%E4%B8%BE/" rel="tag">枚举</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%9E%84%E6%96%87%E5%AD%A6%E5%88%9B%E4%BD%9C%E7%BB%83%E4%B9%A0/" rel="tag">虚构文学创作练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%97/" rel="tag">诗</a></li></ul></div></div></div></div><div class="horizontal-line" style="height: 1px"></div><div class="main__bottom"><div class="pre-next"><a class="pre-button" href="/2020/06/07/%E5%9F%BA%E4%BA%8EC++%E7%9A%84Python3%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html">基于C++的Python3入门笔记</a><a class="next-button" href="/2020/03/20/ArchLinuxConfig.html">Arch Linux安装与配置</a></div></div></div></div><div class="footer"><span>©️2019-2020 Theme Designed By&nbsp;<strong><a href="https://github.com/random-yang" target="_blank" rel="noopener">RandomYang</a></strong> Powered By&nbsp;</span><strong><a href="https://hexo.io" target="_blank" rel="noopener">hexo</a></strong></div><div class="darkmode-mask" id="darkmode-mask"></div><div class="sidebar__button"></div></body></html>